import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, } from '@angular/core';
import { arrayToTree } from './array-to-tree';
export class CollectionTreeComponent {
    constructor() {
        this.expandAll = false;
        this.rearrange = new EventEmitter();
        this.deleteCollection = new EventEmitter();
    }
    ngOnChanges(changes) {
        if ('collections' in changes && this.collections) {
            this.collectionTree = arrayToTree(this.collections, this.collectionTree);
        }
    }
    onDrop(event) {
        const item = event.item.data;
        const newParent = event.container.data;
        const newParentId = newParent.id;
        if (newParentId == null) {
            throw new Error(`Could not determine the ID of the root Collection`);
        }
        this.rearrange.emit({
            collectionId: item.id,
            parentId: newParentId,
            index: event.currentIndex,
        });
    }
    onMove(event) {
        this.rearrange.emit(event);
    }
    onDelete(id) {
        this.deleteCollection.emit(id);
    }
    isRootNode(node) {
        return !node.hasOwnProperty('parent');
    }
}
CollectionTreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'vdr-collection-tree',
                template: "<vdr-collection-tree-node\r\n    *ngIf=\"collectionTree\"\r\n    cdkDropListGroup\r\n    [expandAll]=\"expandAll\"\r\n    [collectionTree]=\"collectionTree\"\r\n    [activeCollectionId]=\"activeCollectionId\"\r\n></vdr-collection-tree-node>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];
CollectionTreeComponent.propDecorators = {
    collections: [{ type: Input }],
    activeCollectionId: [{ type: Input }],
    expandAll: [{ type: Input }],
    rearrange: [{ type: Output }],
    deleteCollection: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi10cmVlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLXRyZWUvY29sbGVjdGlvbi10cmVlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQ0gsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUVMLE1BQU0sR0FFVCxNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsV0FBVyxFQUF1QixNQUFNLGlCQUFpQixDQUFDO0FBV25FLE1BQU0sT0FBTyx1QkFBdUI7SUFOcEM7UUFTYSxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBa0IsQ0FBQztRQUMvQyxxQkFBZ0IsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO0lBa0M1RCxDQUFDO0lBL0JHLFdBQVcsQ0FBQyxPQUFzQjtRQUM5QixJQUFJLGFBQWEsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUM5QyxJQUFJLENBQUMsY0FBYyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUM1RTtJQUNMLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBbUU7UUFDdEUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUF5QixDQUFDO1FBQ2xELE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1FBQ3ZDLE1BQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUM7UUFDakMsSUFBSSxXQUFXLElBQUksSUFBSSxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsbURBQW1ELENBQUMsQ0FBQztTQUN4RTtRQUNELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1lBQ2hCLFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRTtZQUNyQixRQUFRLEVBQUUsV0FBVztZQUNyQixLQUFLLEVBQUUsS0FBSyxDQUFDLFlBQVk7U0FDNUIsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFxQjtRQUN4QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsUUFBUSxDQUFDLEVBQVU7UUFDZixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFTyxVQUFVLENBQXNCLElBQXFCO1FBQ3pELE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFDLENBQUM7OztZQTVDSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHFCQUFxQjtnQkFDL0IsZ1FBQTZDO2dCQUU3QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7YUFDbEQ7OzswQkFFSSxLQUFLO2lDQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxNQUFNOytCQUNOLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZGtEcmFnRHJvcCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9kcmFnLWRyb3AnO1xyXG5pbXBvcnQge1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE91dHB1dCxcclxuICAgIFNpbXBsZUNoYW5nZXMsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICdAdmVuZHVyZS9hZG1pbi11aS9jb3JlJztcclxuXHJcbmltcG9ydCB7IGFycmF5VG9UcmVlLCBIYXNQYXJlbnQsIFJvb3ROb2RlIH0gZnJvbSAnLi9hcnJheS10by10cmVlJztcclxuXHJcbmV4cG9ydCB0eXBlIFJlYXJyYW5nZUV2ZW50ID0geyBjb2xsZWN0aW9uSWQ6IHN0cmluZzsgcGFyZW50SWQ6IHN0cmluZzsgaW5kZXg6IG51bWJlciB9O1xyXG5leHBvcnQgdHlwZSBDb2xsZWN0aW9uUGFydGlhbCA9IFBpY2s8Q29sbGVjdGlvbi5GcmFnbWVudCwgJ2lkJyB8ICdwYXJlbnQnIHwgJ25hbWUnPjtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd2ZHItY29sbGVjdGlvbi10cmVlJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnY29sbGVjdGlvbi10cmVlLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHN0eWxlVXJsczogWycuL2NvbGxlY3Rpb24tdHJlZS5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uVHJlZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgICBASW5wdXQoKSBjb2xsZWN0aW9uczogQ29sbGVjdGlvblBhcnRpYWxbXTtcclxuICAgIEBJbnB1dCgpIGFjdGl2ZUNvbGxlY3Rpb25JZDogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgZXhwYW5kQWxsID0gZmFsc2U7XHJcbiAgICBAT3V0cHV0KCkgcmVhcnJhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxSZWFycmFuZ2VFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSBkZWxldGVDb2xsZWN0aW9uID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XHJcbiAgICBjb2xsZWN0aW9uVHJlZTogUm9vdE5vZGU8Q29sbGVjdGlvblBhcnRpYWw+O1xyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoJ2NvbGxlY3Rpb25zJyBpbiBjaGFuZ2VzICYmIHRoaXMuY29sbGVjdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uVHJlZSA9IGFycmF5VG9UcmVlKHRoaXMuY29sbGVjdGlvbnMsIHRoaXMuY29sbGVjdGlvblRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkRyb3AoZXZlbnQ6IENka0RyYWdEcm9wPENvbGxlY3Rpb25QYXJ0aWFsIHwgUm9vdE5vZGU8Q29sbGVjdGlvblBhcnRpYWw+Pikge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBldmVudC5pdGVtLmRhdGEgYXMgQ29sbGVjdGlvblBhcnRpYWw7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gZXZlbnQuY29udGFpbmVyLmRhdGE7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyZW50SWQgPSBuZXdQYXJlbnQuaWQ7XHJcbiAgICAgICAgaWYgKG5ld1BhcmVudElkID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZGV0ZXJtaW5lIHRoZSBJRCBvZiB0aGUgcm9vdCBDb2xsZWN0aW9uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVhcnJhbmdlLmVtaXQoe1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IGl0ZW0uaWQsXHJcbiAgICAgICAgICAgIHBhcmVudElkOiBuZXdQYXJlbnRJZCxcclxuICAgICAgICAgICAgaW5kZXg6IGV2ZW50LmN1cnJlbnRJbmRleCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1vdmUoZXZlbnQ6IFJlYXJyYW5nZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5yZWFycmFuZ2UuZW1pdChldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25EZWxldGUoaWQ6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuZGVsZXRlQ29sbGVjdGlvbi5lbWl0KGlkKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlzUm9vdE5vZGU8VCBleHRlbmRzIEhhc1BhcmVudD4obm9kZTogVCB8IFJvb3ROb2RlPFQ+KTogbm9kZSBpcyBSb290Tm9kZTxUPiB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmhhc093blByb3BlcnR5KCdwYXJlbnQnKTtcclxuICAgIH1cclxufVxyXG4iXX0=