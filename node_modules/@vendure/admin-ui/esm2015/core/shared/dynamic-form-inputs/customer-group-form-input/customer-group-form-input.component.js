import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { startWith } from 'rxjs/operators';
import { DataService } from '../../../data/providers/data.service';
export class CustomerGroupFormInputComponent {
    constructor(dataService) {
        this.dataService = dataService;
    }
    ngOnInit() {
        this.customerGroups$ = this.dataService.customer
            .getCustomerGroupList({
            take: 1000,
        })
            .mapSingle(res => res.customerGroups.items)
            .pipe(startWith([]));
    }
    selectGroup(group) {
        this.formControl.setValue(group.id);
    }
}
CustomerGroupFormInputComponent.id = 'customer-group-form-input';
CustomerGroupFormInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'vdr-customer-group-form-input',
                template: "<ng-select\r\n    [items]=\"customerGroups$ | async\"\r\n    appendTo=\"body\"\r\n    [addTag]=\"false\"\r\n    [multiple]=\"false\"\r\n    bindValue=\"id\"\r\n    [clearable]=\"true\"\r\n    [searchable]=\"false\"\r\n    [ngModel]=\"formControl.value\"\r\n    (change)=\"selectGroup($event)\"\r\n>\r\n    <ng-template ng-label-tmp let-item=\"item\" let-clear=\"clear\">\r\n        <vdr-chip [colorFrom]=\"item.id\">{{ item.name }}</vdr-chip>\r\n    </ng-template>\r\n    <ng-template ng-option-tmp let-item=\"item\">\r\n        <vdr-chip [colorFrom]=\"item.id\">{{ item.name }}</vdr-chip>\r\n    </ng-template>\r\n</ng-select>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];
CustomerGroupFormInputComponent.ctorParameters = () => [
    { type: DataService }
];
CustomerGroupFormInputComponent.propDecorators = {
    readonly: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tZXItZ3JvdXAtZm9ybS1pbnB1dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9keW5hbWljLWZvcm0taW5wdXRzL2N1c3RvbWVyLWdyb3VwLWZvcm0taW5wdXQvY3VzdG9tZXItZ3JvdXAtZm9ybS1pbnB1dC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFJbEYsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSTNDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQVFuRSxNQUFNLE9BQU8sK0JBQStCO0lBT3hDLFlBQW9CLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0lBQUcsQ0FBQztJQUVoRCxRQUFRO1FBQ0osSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVE7YUFDM0Msb0JBQW9CLENBQUM7WUFDbEIsSUFBSSxFQUFFLElBQUk7U0FDYixDQUFDO2FBQ0QsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUM7YUFDMUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxXQUFXLENBQUMsS0FBOEI7UUFDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7O0FBbkJlLGtDQUFFLEdBQTJCLDJCQUEyQixDQUFDOztZQVA1RSxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLCtCQUErQjtnQkFDekMsbW9CQUF5RDtnQkFFekQsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O2FBQ2xEOzs7WUFQUSxXQUFXOzs7dUJBVWYsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IERlZmF1bHRGb3JtQ29tcG9uZW50Q29uZmlnLCBEZWZhdWx0Rm9ybUNvbXBvbmVudElkIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9zaGFyZWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IEZvcm1JbnB1dENvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9jb21wb25lbnQtcmVnaXN0cnktdHlwZXMnO1xyXG5pbXBvcnQgeyBHZXRDdXN0b21lckdyb3VwcyB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9nZW5lcmF0ZWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBEYXRhU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2RhdGEvcHJvdmlkZXJzL2RhdGEuc2VydmljZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndmRyLWN1c3RvbWVyLWdyb3VwLWZvcm0taW5wdXQnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL2N1c3RvbWVyLWdyb3VwLWZvcm0taW5wdXQuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vY3VzdG9tZXItZ3JvdXAtZm9ybS1pbnB1dC5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDdXN0b21lckdyb3VwRm9ybUlucHV0Q29tcG9uZW50IGltcGxlbWVudHMgRm9ybUlucHV0Q29tcG9uZW50LCBPbkluaXQge1xyXG4gICAgc3RhdGljIHJlYWRvbmx5IGlkOiBEZWZhdWx0Rm9ybUNvbXBvbmVudElkID0gJ2N1c3RvbWVyLWdyb3VwLWZvcm0taW5wdXQnO1xyXG4gICAgQElucHV0KCkgcmVhZG9ubHk6IGJvb2xlYW47XHJcbiAgICBmb3JtQ29udHJvbDogRm9ybUNvbnRyb2w7XHJcbiAgICBjdXN0b21lckdyb3VwcyQ6IE9ic2VydmFibGU8R2V0Q3VzdG9tZXJHcm91cHMuSXRlbXNbXT47XHJcbiAgICBjb25maWc6IERlZmF1bHRGb3JtQ29tcG9uZW50Q29uZmlnPCdjdXN0b21lci1ncm91cC1mb3JtLWlucHV0Jz47XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UpIHt9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5jdXN0b21lckdyb3VwcyQgPSB0aGlzLmRhdGFTZXJ2aWNlLmN1c3RvbWVyXHJcbiAgICAgICAgICAgIC5nZXRDdXN0b21lckdyb3VwTGlzdCh7XHJcbiAgICAgICAgICAgICAgICB0YWtlOiAxMDAwLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAubWFwU2luZ2xlKHJlcyA9PiByZXMuY3VzdG9tZXJHcm91cHMuaXRlbXMpXHJcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aChbXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdEdyb3VwKGdyb3VwOiBHZXRDdXN0b21lckdyb3Vwcy5JdGVtcykge1xyXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUoZ3JvdXAuaWQpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==