import { HttpErrorResponse, HttpResponse, } from '@angular/common/http';
import { Injectable, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { marker as _ } from '@biesbjerg/ngx-translate-extract-marker';
import { DEFAULT_AUTH_TOKEN_HEADER_KEY } from '@vendure/common/lib/shared-constants';
import { switchMap, tap } from 'rxjs/operators';
import { getAppConfig } from '../../app.config';
import { AuthService } from '../../providers/auth/auth.service';
import { LocalStorageService } from '../../providers/local-storage/local-storage.service';
import { NotificationService } from '../../providers/notification/notification.service';
import { DataService } from '../providers/data.service';
export const AUTH_REDIRECT_PARAM = 'redirectTo';
/**
 * The default interceptor examines all HTTP requests & responses and automatically updates the requesting state
 * and shows error notifications.
 */
export class DefaultInterceptor {
    constructor(dataService, injector, authService, router, localStorageService) {
        this.dataService = dataService;
        this.injector = injector;
        this.authService = authService;
        this.router = router;
        this.localStorageService = localStorageService;
        this.tokenMethod = 'cookie';
        this.tokenMethod = getAppConfig().tokenMethod;
        this.authTokenHeaderKey = getAppConfig().authTokenHeaderKey || DEFAULT_AUTH_TOKEN_HEADER_KEY;
    }
    intercept(req, next) {
        this.dataService.client.startRequest().subscribe();
        return this.dataService.client.uiState().single$.pipe(switchMap(({ uiState }) => {
            var _a;
            const request = req.clone({
                setParams: {
                    languageCode: (_a = uiState === null || uiState === void 0 ? void 0 : uiState.contentLanguage) !== null && _a !== void 0 ? _a : '',
                },
            });
            return next.handle(request);
        }), tap(event => {
            if (event instanceof HttpResponse) {
                this.checkForAuthToken(event);
                this.notifyOnError(event);
                this.dataService.client.completeRequest().subscribe();
            }
        }, err => {
            if (err instanceof HttpErrorResponse) {
                this.notifyOnError(err);
                this.dataService.client.completeRequest().subscribe();
            }
            else {
                this.displayErrorNotification(err.message);
            }
        }));
    }
    notifyOnError(response) {
        var _a, _b, _c;
        if (response instanceof HttpErrorResponse) {
            if (response.status === 0) {
                const { apiHost, apiPort } = getAppConfig();
                this.displayErrorNotification(_(`error.could-not-connect-to-server`), {
                    url: `${apiHost}:${apiPort}`,
                });
            }
            else if (response.status === 503 && ((_a = response.url) === null || _a === void 0 ? void 0 : _a.endsWith('/health'))) {
                this.displayErrorNotification(_(`error.health-check-failed`));
            }
            else {
                this.displayErrorNotification(this.extractErrorFromHttpResponse(response));
            }
        }
        else {
            // GraphQL errors still return 200 OK responses, but have the actual error message
            // inside the body of the response.
            const graqhQLErrors = response.body.errors;
            if (graqhQLErrors && Array.isArray(graqhQLErrors)) {
                const firstCode = (_c = (_b = graqhQLErrors[0]) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.code;
                if (firstCode === 'FORBIDDEN') {
                    this.authService.logOut().subscribe(() => {
                        if (!window.location.pathname.includes('login')) {
                            const path = graqhQLErrors[0].path.join(' > ');
                            this.displayErrorNotification(_(`error.403-forbidden`), { path });
                        }
                        this.router.navigate(['/login'], {
                            queryParams: {
                                [AUTH_REDIRECT_PARAM]: btoa(this.router.url),
                            },
                        });
                    });
                }
                else if (firstCode === 'CHANNEL_NOT_FOUND') {
                    const message = graqhQLErrors.map(err => err.message).join('\n');
                    this.displayErrorNotification(message);
                    this.localStorageService.remove('activeChannelToken');
                }
                else {
                    const message = graqhQLErrors.map(err => err.message).join('\n');
                    this.displayErrorNotification(message);
                }
            }
        }
    }
    extractErrorFromHttpResponse(response) {
        const errors = response.error.errors;
        if (Array.isArray(errors)) {
            return errors.map(e => e.message).join('\n');
        }
        else {
            return response.message;
        }
    }
    /**
     * We need to lazily inject the NotificationService since it depends on the I18nService which
     * eventually depends on the HttpClient (used to load messages from json files). If we were to
     * directly inject NotificationService into the constructor, we get a cyclic dependency.
     */
    displayErrorNotification(message, vars) {
        const notificationService = this.injector.get(NotificationService);
        notificationService.error(message, vars);
    }
    /**
     * If the server is configured to use the "bearer" tokenMethod, each response should be checked
     * for the existence of an auth token.
     */
    checkForAuthToken(response) {
        if (this.tokenMethod === 'bearer') {
            const authToken = response.headers.get(this.authTokenHeaderKey);
            if (authToken) {
                this.localStorageService.set('authToken', authToken);
            }
        }
    }
}
DefaultInterceptor.decorators = [
    { type: Injectable }
];
DefaultInterceptor.ctorParameters = () => [
    { type: DataService },
    { type: Injector },
    { type: AuthService },
    { type: Router },
    { type: LocalStorageService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL2RhdGEvcHJvdmlkZXJzL2ludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFLakIsWUFBWSxHQUNmLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQyxFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDdEUsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFHckYsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVoRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHFEQUFxRCxDQUFDO0FBQzFGLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQ3hGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUV4RCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxZQUFZLENBQUM7QUFFaEQ7OztHQUdHO0FBRUgsTUFBTSxPQUFPLGtCQUFrQjtJQUkzQixZQUNZLFdBQXdCLEVBQ3hCLFFBQWtCLEVBQ2xCLFdBQXdCLEVBQ3hCLE1BQWMsRUFDZCxtQkFBd0M7UUFKeEMsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDeEIsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNsQixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixX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dXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBIdHRwRXJyb3JSZXNwb25zZSxcclxuICAgIEh0dHBFdmVudCxcclxuICAgIEh0dHBIYW5kbGVyLFxyXG4gICAgSHR0cEludGVyY2VwdG9yLFxyXG4gICAgSHR0cFJlcXVlc3QsXHJcbiAgICBIdHRwUmVzcG9uc2UsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBtYXJrZXIgYXMgXyB9IGZyb20gJ0BiaWVzYmplcmcvbmd4LXRyYW5zbGF0ZS1leHRyYWN0LW1hcmtlcic7XHJcbmltcG9ydCB7IERFRkFVTFRfQVVUSF9UT0tFTl9IRUFERVJfS0VZIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9zaGFyZWQtY29uc3RhbnRzJztcclxuaW1wb3J0IHsgQWRtaW5VaUNvbmZpZyB9IGZyb20gJ0B2ZW5kdXJlL2NvbW1vbi9saWIvc2hhcmVkLXR5cGVzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBzd2l0Y2hNYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IGdldEFwcENvbmZpZyB9IGZyb20gJy4uLy4uL2FwcC5jb25maWcnO1xyXG5pbXBvcnQgeyBBdXRoU2VydmljZSB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9hdXRoL2F1dGguc2VydmljZSc7XHJcbmltcG9ydCB7IExvY2FsU3RvcmFnZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvbG9jYWwtc3RvcmFnZS9sb2NhbC1zdG9yYWdlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24uc2VydmljZSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2RhdGEuc2VydmljZSc7XHJcblxyXG5leHBvcnQgY29uc3QgQVVUSF9SRURJUkVDVF9QQVJBTSA9ICdyZWRpcmVjdFRvJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBpbnRlcmNlcHRvciBleGFtaW5lcyBhbGwgSFRUUCByZXF1ZXN0cyAmIHJlc3BvbnNlcyBhbmQgYXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSByZXF1ZXN0aW5nIHN0YXRlXHJcbiAqIGFuZCBzaG93cyBlcnJvciBub3RpZmljYXRpb25zLlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRGVmYXVsdEludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdG9rZW5NZXRob2Q6IEFkbWluVWlDb25maWdbJ3Rva2VuTWV0aG9kJ10gPSAnY29va2llJztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXV0aFRva2VuSGVhZGVyS2V5OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXHJcbiAgICAgICAgcHJpdmF0ZSBhdXRoU2VydmljZTogQXV0aFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcclxuICAgICAgICBwcml2YXRlIGxvY2FsU3RvcmFnZVNlcnZpY2U6IExvY2FsU3RvcmFnZVNlcnZpY2UsXHJcbiAgICApIHtcclxuICAgICAgICB0aGlzLnRva2VuTWV0aG9kID0gZ2V0QXBwQ29uZmlnKCkudG9rZW5NZXRob2Q7XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5IZWFkZXJLZXkgPSBnZXRBcHBDb25maWcoKS5hdXRoVG9rZW5IZWFkZXJLZXkgfHwgREVGQVVMVF9BVVRIX1RPS0VOX0hFQURFUl9LRVk7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJjZXB0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XHJcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZS5jbGllbnQuc3RhcnRSZXF1ZXN0KCkuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuY2xpZW50LnVpU3RhdGUoKS5zaW5nbGUkLnBpcGUoXHJcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoeyB1aVN0YXRlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXEuY2xvbmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZUNvZGU6IHVpU3RhdGU/LmNvbnRlbnRMYW5ndWFnZSA/PyAnJyxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxdWVzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB0YXAoXHJcbiAgICAgICAgICAgICAgICBldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JBdXRoVG9rZW4oZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9uRXJyb3IoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLmNsaWVudC5jb21wbGV0ZVJlcXVlc3QoKS5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cEVycm9yUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNlcnZpY2UuY2xpZW50LmNvbXBsZXRlUmVxdWVzdCgpLnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBub3RpZnlPbkVycm9yKHJlc3BvbnNlOiBIdHRwUmVzcG9uc2U8YW55PiB8IEh0dHBFcnJvclJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgSHR0cEVycm9yUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcGlIb3N0LCBhcGlQb3J0IH0gPSBnZXRBcHBDb25maWcoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKF8oYGVycm9yLmNvdWxkLW5vdC1jb25uZWN0LXRvLXNlcnZlcmApLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBgJHthcGlIb3N0fToke2FwaVBvcnR9YCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAzICYmIHJlc3BvbnNlLnVybD8uZW5kc1dpdGgoJy9oZWFsdGgnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24oXyhgZXJyb3IuaGVhbHRoLWNoZWNrLWZhaWxlZGApKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKHRoaXMuZXh0cmFjdEVycm9yRnJvbUh0dHBSZXNwb25zZShyZXNwb25zZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gR3JhcGhRTCBlcnJvcnMgc3RpbGwgcmV0dXJuIDIwMCBPSyByZXNwb25zZXMsIGJ1dCBoYXZlIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZVxyXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIGJvZHkgb2YgdGhlIHJlc3BvbnNlLlxyXG4gICAgICAgICAgICBjb25zdCBncmFxaFFMRXJyb3JzID0gcmVzcG9uc2UuYm9keS5lcnJvcnM7XHJcbiAgICAgICAgICAgIGlmIChncmFxaFFMRXJyb3JzICYmIEFycmF5LmlzQXJyYXkoZ3JhcWhRTEVycm9ycykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29kZTogc3RyaW5nID0gZ3JhcWhRTEVycm9yc1swXT8uZXh0ZW5zaW9ucz8uY29kZTtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvZGUgPT09ICdGT1JCSURERU4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoU2VydmljZS5sb2dPdXQoKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5pbmNsdWRlcygnbG9naW4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGdyYXFoUUxFcnJvcnNbMF0ucGF0aC5qb2luKCcgPiAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKF8oYGVycm9yLjQwMy1mb3JiaWRkZW5gKSwgeyBwYXRoIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnL2xvZ2luJ10sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0FVVEhfUkVESVJFQ1RfUEFSQU1dOiBidG9hKHRoaXMucm91dGVyLnVybCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RDb2RlID09PSAnQ0hBTk5FTF9OT1RfRk9VTkQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdyYXFoUUxFcnJvcnMubWFwKGVyciA9PiBlcnIubWVzc2FnZSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2VTZXJ2aWNlLnJlbW92ZSgnYWN0aXZlQ2hhbm5lbFRva2VuJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBncmFxaFFMRXJyb3JzLm1hcChlcnIgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZXh0cmFjdEVycm9yRnJvbUh0dHBSZXNwb25zZShyZXNwb25zZTogSHR0cEVycm9yUmVzcG9uc2UpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IHJlc3BvbnNlLmVycm9yLmVycm9ycztcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnMubWFwKGUgPT4gZS5tZXNzYWdlKS5qb2luKCdcXG4nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXZSBuZWVkIHRvIGxhemlseSBpbmplY3QgdGhlIE5vdGlmaWNhdGlvblNlcnZpY2Ugc2luY2UgaXQgZGVwZW5kcyBvbiB0aGUgSTE4blNlcnZpY2Ugd2hpY2hcclxuICAgICAqIGV2ZW50dWFsbHkgZGVwZW5kcyBvbiB0aGUgSHR0cENsaWVudCAodXNlZCB0byBsb2FkIG1lc3NhZ2VzIGZyb20ganNvbiBmaWxlcykuIElmIHdlIHdlcmUgdG9cclxuICAgICAqIGRpcmVjdGx5IGluamVjdCBOb3RpZmljYXRpb25TZXJ2aWNlIGludG8gdGhlIGNvbnN0cnVjdG9yLCB3ZSBnZXQgYSBjeWNsaWMgZGVwZW5kZW5jeS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkaXNwbGF5RXJyb3JOb3RpZmljYXRpb24obWVzc2FnZTogc3RyaW5nLCB2YXJzPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvblNlcnZpY2UgPSB0aGlzLmluamVjdG9yLmdldDxOb3RpZmljYXRpb25TZXJ2aWNlPihOb3RpZmljYXRpb25TZXJ2aWNlKTtcclxuICAgICAgICBub3RpZmljYXRpb25TZXJ2aWNlLmVycm9yKG1lc3NhZ2UsIHZhcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIHNlcnZlciBpcyBjb25maWd1cmVkIHRvIHVzZSB0aGUgXCJiZWFyZXJcIiB0b2tlbk1ldGhvZCwgZWFjaCByZXNwb25zZSBzaG91bGQgYmUgY2hlY2tlZFxyXG4gICAgICogZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gYXV0aCB0b2tlbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja0ZvckF1dGhUb2tlbihyZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT4pIHtcclxuICAgICAgICBpZiAodGhpcy50b2tlbk1ldGhvZCA9PT0gJ2JlYXJlcicpIHtcclxuICAgICAgICAgICAgY29uc3QgYXV0aFRva2VuID0gcmVzcG9uc2UuaGVhZGVycy5nZXQodGhpcy5hdXRoVG9rZW5IZWFkZXJLZXkpO1xyXG4gICAgICAgICAgICBpZiAoYXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsU3RvcmFnZVNlcnZpY2Uuc2V0KCdhdXRoVG9rZW4nLCBhdXRoVG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==