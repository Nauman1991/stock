import { LitElement, PropertyValues } from 'lit';
import { Animatable, EventEmitter } from '@cds/core/internal';
import { FocusableElement } from './utils/index.js';
import { CdsNavigationGroup } from './navigation-group.element.js';
import { CdsNavigationStart } from './navigation-start.element.js';
import { CdsNavigationItem } from './navigation-item.element.js';
import { CdsDivider } from '@cds/core/divider/index.js';
export declare const CdsNavigationTagName = "cds-navigation";
/**
 * ```typescript
 * import '@cds/core/navigation/register.js';
 * ```
 *
 * ```html
 *  <cds-navigation>
 *    <cds-navigation-item><a href="/home">Home</cds-navigation-item>
 *    <cds-navigation-item><a href="/account">Account</cds-navigation-item>
 *  </cds-navigation>
 * ```
 *
 * @beta
 * @element cds-navigation
 * @event expandedChange - notify when the user has clicked the navigation expand/collapse button
 * @cssprop --animation-duration
 * @cssprop --animation-easing
 * @cssprop --background
 * @cssprop --collapsed-width
 * @cssprop --expanded-width
 * @cssprop --font-size
 * @cssprop --font-weight
 * @cssprop --letter-spacing
 * @cssprop --line-height
 * @cssprop --nested-padding
 * @cssprop --padding
 * @slot
 * @slot - cds-navigation-substart - project content below the navigation toggle button
 * @slot - cds-navigation-end - project content below the scrollable section
 */
export declare class CdsNavigation extends LitElement implements Animatable {
    expandedRoot: boolean;
    cdsMotion: string;
    protected expandedChange: EventEmitter<boolean>;
    cdsMotionChange: EventEmitter<string>;
    /**
     * This is used to sync down the information to this.navigationGroupItems
     *
     * @type { boolean }
     * @protected
     */
    protected groupItem: boolean;
    /**
     * Set and update the aria-active descended value onto the navigation.
     */
    ariaActiveDescendant: any;
    /**
     *
     * Vertical navigation elements can be either wide or narrow. Expanded indicates it should be wide.
     * When navigation is wide cds-navigation-start button elements and cds-navigation-item a elements display
     * text. When it is narrow they do not (consumer should provide an icon that stays visible).
  
     * @type {boolean}
     */
    expanded: boolean;
    i18n: {
        [key: string]: string | undefined;
    };
    /**
     * The end slot that items can be projected into with slot="cds-navigation-end"
     */
    protected navigationEnd: HTMLElement;
    /**
     * This slot query is used to identify and manage all focusable elements needed for arrow key navigation
     * TODO: How to add in forms selector attribute and other things that are not FocusableElements like I use here
     * tbd - I don;'t have an answer yet.
     */
    protected allNavigationElements: NodeListOf<FocusableElement>;
    /**
     * Get references to all of the start elements so they can be passed state when updates are made.
     */
    protected navigationStartRefs: NodeListOf<CdsNavigationStart>;
    /** make navigation-body default and eliminate extra assigns **?
    /**
     * query for cds-divider  and project into navigation-body slot.
     */
    protected rootDividers: NodeListOf<CdsDivider>;
    /**
     * query for root level groups and project them into the navigation-body slot.
     */
    protected rootNavigationGroups: NodeListOf<CdsNavigationGroup>;
    /**
     * query for root level items and project them into the navigation-body slot.
     */
    protected rootNavigationItems: NodeListOf<CdsNavigationItem>;
    /**
     * query for the root level start items and project them into the navigation-start slot.
     */
    protected rootNavigationStart: CdsNavigationStart;
    /**
     * query for items inside a cds-navigation-group, used to pass state down
     */
    protected navigationGroupItems: NodeListOf<CdsNavigationGroup>;
    /**
     * query for all cds-navigation elements, used to pass state down
     */
    protected navigationItemRefs: NodeListOf<CdsNavigationItem>;
    /**
     * query for all groups (including any nested groups), used ot pass state down
     */
    protected navigationGroupRefs: NodeListOf<CdsNavigationGroup>;
    private initAriaActiveDescendant;
    /**
     * Rules for keyboard handling logic:
     *
     * 1. when cds-navigation element receives focus if there is already an active focus item,
     *    set focus on it, else set focus on first focusable item
     * 2. arrow key down sets focus on the next focusable item, if last item it moves focus to first focusable item
     * 3. arrow key up sets focus on the previous focusable item, if first it moves focus to the last focusable item
     * 4. arrow key left on a cds-navigation-item inside cds-navigation-group will put focus on the cds-navigation-start
     *    button for the group
     * 5. arrow key left on a cds-navigation-start element inside a cds-navigation-group will emit the groups
     *    expandedChange event
     * 6. arrow key right on a non expanded cds-navigation-group will emit the groups expandedChange event
     * 7. arrow key left on a root cds-navigation-start element will fire the cds-navigation expandedChange event if
     *    the cds-navigation element is expanded
     * 8. arrow key right on a root cds-navigation-start element will fire the cds-navigation expandedChange event if
     *    the cds-navigation element is not expanded
     * 9. home key will move focus to the first focusable item
     * 10. end key will move focus to the last focusable item
     *
     * We may need a way to let consumers mark elements and include them in the focusable elements, not sure how yet
     *
     * @param event
     * @private
     */
    private keyboardNavigationHandler;
    private toggle;
    get currentActiveItem(): FocusableElement | undefined;
    protected get endTemplate(): "" | import("lit-html").TemplateResult<1>;
    protected get startTemplate(): string | import("lit-html").TemplateResult<1>;
    protected get visibleChildren(): FocusableElement[];
    addStartEventListener(): void;
    firstUpdated(props: PropertyValues): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
    private setActiveItemFocus;
    render(): import("lit-html").TemplateResult<1>;
    updated(props: PropertyValues<this>): void;
    updateChildrenProps(): void;
    static get styles(): import("lit").CSSResultGroup[];
}
